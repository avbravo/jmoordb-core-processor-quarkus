package com.jmoordb.core.processor.analizer.autosecuencerepository;


import com.jmoordb.core.annotation.autosecuence.Autogenerated;
import com.jmoordb.core.processor.internal.MethodProcessorAux;
import static com.jmoordb.core.processor.builder.RepositorySourceBuilder.LINE_BREAK;
import com.jmoordb.core.util.MessagesUtil;
import com.jmoordb.core.util.ProcessorUtil;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.util.ElementFilter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import javax.annotation.processing.Messager;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;

/**
 * Converts getters to field
 */
public class AutosecuenceRepositoryAnalizer {
// <editor-fold defaultstate="collapsed" desc="fields()">

    private Messager messager;
    private StringBuilder builderMethods = new StringBuilder();

    private final LinkedHashMap<String, String> fields;
    private final List<String> mandatoryFields;

    public AutosecuenceRepositoryAnalizer(LinkedHashMap<String, String> fields, List<String> mandatoryFields) {

        this.fields = fields;
        this.mandatoryFields = mandatoryFields;
    }
    // </editor-fold>
// <editor-fold defaultstate="collapsed" desc="set/get">

    public LinkedHashMap<String, String> getFields() {
        return fields;
    }

    public List<String> getMandatoryFields() {
        return mandatoryFields;
    }
// </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="RepositoryAnalizer get(Element element)">

    /**
     * Procesa los metodos definidos en la interface
     *
     * @param element
     * @return
     */
    public static AutosecuenceRepositoryAnalizer get(Element element, Messager messager, String database, TypeMirror typeEntity) {
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();
        List<String> mandatoryFields = new ArrayList<>();

        for (ExecutableElement executableElement : ElementFilter.methodsIn(element.getEnclosedElements())) {

            if (executableElement.getKind() != ElementKind.METHOD) {
                continue;
            }
            
            /**
             * Obtiene el nombre del metodo
             */
//            String methodName = executableElement.getSimpleName().toString();
            String methodName = ProcessorUtil.nameOfMethod(executableElement);
         
            if(!methodName.equals("generate")){
                 messager.printMessage(Diagnostic.Kind.ERROR,"wrong method name, only generate is allowed", element);
            }
            /**
             * Obtengo el valor de retorno
             */
            TypeMirror returnTypeOfMethod = executableElement.getReturnType();
         

            List<? extends VariableElement> parameters = executableElement.getParameters();
            if (parameters.size() <= 0) {
         //      MessagesUtil.msg("[ NO TIENE PARAMETROS ] ");
            } else {
                /**
                 * Aqui se pueden consultar los parametros del método
                 */
//                for (int i = 0; i < parameters.size(); i++) {
//                    VariableElement param = parameters.get(i);
//                    MessagesUtil.msg("param.asType(): " + param.asType().toString() + "   " + param.getSimpleName().toString());
//                }

            }

            /*

             */
            if (!haveAnnotationValid(executableElement)) {
                // No tiene anotaciones validas
                messager.printMessage(Diagnostic.Kind.ERROR, "Methods" + methodName + " without declaring valid annotation for a AutosecuenceRepository interface", element);
                return new AutosecuenceRepositoryAnalizer(fields, mandatoryFields);
            }

            /**
             * Verifico si el metodo tiene anotación Query.classs E invoco el
             * analizador de la anotación
             */
           Autogenerated autogenerated = executableElement.getAnnotation(Autogenerated.class);
            if (autogenerated != null) {

                if (!AutogeneratedAnalizer.analizer(autogenerated, element, executableElement, typeEntity)) {
                    messager.printMessage(Diagnostic.Kind.ERROR, AutogeneratedAnalizer.getMessage(), element);
                }
            }else{
                 messager.printMessage(Diagnostic.Kind.ERROR,"is only allowed to use @Autogenerated", element);
            }

            

            
        }

        return new AutosecuenceRepositoryAnalizer(fields, mandatoryFields);
    }
// </editor-fold>

    // <editor-fold defaultstate="collapsed" desc="String methodToFieldName(String methodName)">
    /**
     *
     * @param methodName
     * @return
     */
    private static String methodToFieldName(String methodName) {
        if (methodName.startsWith("get")) {
            String str = methodName.substring(3);
            if (str.length() == 0) {
                return null;
            } else if (str.length() == 1) {
                return str.toLowerCase();
            } else {
                return Character.toLowerCase(str.charAt(0)) + str.substring(1);
            }
        } else {

        }
        if (methodName.startsWith("find")) {
            String str = methodName.substring(4);
            if (str.length() == 0) {
                return null;
            } else if (str.length() == 1) {
                return str.toLowerCase();
            } else {
                return Character.toLowerCase(str.charAt(0)) + str.substring(1);
            }
        } else {
            if (methodName.startsWith("delete")) {
                String str = methodName.substring(6);
                if (str.length() == 0) {
                    return null;
                } else if (str.length() == 1) {
                    return str.toLowerCase();
                } else {
                    return Character.toLowerCase(str.charAt(0)) + str.substring(1);
                }
            }
        }
        return null;
    }

    // </editor-fold>
    /**
     * Verifica que tenga un anotación valida para el repositorio
     *
     * @param method
     * @return
     */
    private static Boolean haveAnnotationValid(ExecutableElement executableElement) {
        Boolean isValid = Boolean.FALSE;
        try {
            Autogenerated autogenerated = executableElement.getAnnotation(Autogenerated.class);
         
            if (autogenerated != null ) {
          
                return Boolean.TRUE;
            }

        } catch (Exception e) {
            MessagesUtil.error(MessagesUtil.nameOfClassAndMethod() + " error() " + e.getLocalizedMessage());
        }
        return isValid;
    }

    public AutosecuenceRepositoryAnalizer addMethod(MethodProcessorAux method) {
        builderMethods.append(LINE_BREAK)
                .append(method.end())
                .append(LINE_BREAK);
        return this;
    }
}
